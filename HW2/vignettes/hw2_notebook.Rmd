---
title: "STAT 745: Homework 2"
author: "Ian Effendi (iae2784@rit.edu)"
date: "9/16/2021"
output:
  pdf_document:
    toc: TRUE
    toc_depth: 3
  html_notebook:
    toc: TRUE
    toc_depth: 3
---

```{r setup, message=FALSE, warning=FALSE, cache=FALSE, include=FALSE}
# Notebook related requirements.
require(knitr)
require(rprojroot)

# Setup the document settings.
knitr::opts_knit$set(
  # No matter where notebook is, working directory is the project root.
  root.dir = rprojroot::find_rstudio_root_file()
)

# Setup the chunk options.
knitr::opts_chunk$set(
  paged.print = TRUE,
  cache = FALSE,
  collapse = TRUE,
  echo = TRUE,
  warning = TRUE,
  message = TRUE,
  comment = "#> ",
  R.options = list(width = 60)
)
```

```{r install-requirements, echo=FALSE, include=FALSE}
# Required packages
require(knitr)
require(rmarkdown)
require(tidyverse) # readr, tibble, ggplot2
```
```{r show-requirements, ref.label="install-requirements", collapse=TRUE, eval=FALSE}
```

## Overview

This section provides an overview of the document.

For this assignment, we will be exploring the `Livers.txt` data set, detailing various liver and blood conditions of 345 men, with the goal of predicting liver disorder severity.

<!-- PAGE BREAK -->
\newpage

## Preprocess

In this section, I clean up the `Liver.txt` data source and output an intermediary data file to make it easier to perform classification with the data.

### Contents of `Liver.txt`

*1. Read in the data from the text file `"Liver.txt"`.*

The data is stored in a raw text file with comma-separated values. We can use `readr::read_csv()` on this file as-is to get our data into R. Additionally, the `read_csv()` accepts a `col_types` parameter that allows us to designate the types for each of the features.

```{r load-data-raw, echo=TRUE}
# Read raw text file into a tibble.
Liver.txt <- as_tibble(read_csv(
  # File is located in the data/raw folder.
  file = "data/raw/Liver.txt",
  # First row is not a header row, so we should set `col_names` to FALSE.
  col_names = FALSE,
  # The column type choices are described below.
  col_types = cols(
    # 1 through 5 are quantitative.
    X1 = col_integer(),
    X2 = col_integer(),
    X3 = col_integer(),
    X4 = col_integer(),
    X5 = col_integer(),
    # No. of alcoholic beverages drunk.
    X6 = col_double(),
    # Severity group of the liver condition.
    X7 = col_factor(),
  )
))

# Preview the first 10 rows from the data set.
Liver.txt
```

We can see the tibble contains $345$ rows and a total of $7$ columns, which matches our expectations from the assignment details.

### Clean `Liver.txt`

The assignment document provides some information about the features in the data set. We know that:

- Variables 1 through 5 are quantitative results of blood tests sensitive to liver disorders.
  - Inference: These are stored as whole integers in the original file, so a `<int>` type seems appropriate.
  - Concern: We don't really know what units these are stored with; if they are percentages, some level of scaling or data transformation may have been appropriate.
- Variable 6 is the number of alcoholic beverages drunk per day.
  - Inference: This is stored as a fractional numeric, so despite being described as something that I would assume is a discrete integer, we'll store this as a `<dbl>` as well.
- Variable 7 is the response, demarcating the liver malfunctioning group.
  - Inference: This is a factor. Given this is a classification problem, we should store this as a categorical `<fctr>` type.

```{r rename-data}
# Normalize column names to lowercase.
Liver.1 <- rename_with(Liver.txt, tolower)

# Rename some column names to be more descriptive.
# Uses `dplyr::rename(.data, new.name = old.name)

# x1 through x5 will have similar naming convention
# as they are blood test results sensitive to liver conditions.
Liver.1 <- rename(Liver.1, blood.1 = x1)
Liver.1 <- rename(Liver.1, blood.2 = x2)
Liver.1 <- rename(Liver.1, blood.3 = x3)
Liver.1 <- rename(Liver.1, blood.4 = x4)
Liver.1 <- rename(Liver.1, blood.5 = x5)

# x6 -> drinks
Liver.1 <- rename(Liver.1, drinks = x6)

# x7 -> severity
Liver.1 <- rename(Liver.1, severity = x7)

# Preview changes to column names.
names(Liver.1)
```
Now that the fields are named appropriately, I want to finish cleaning the data up by encoding the `severity` factor as a binary field.

```{r encode-data-map, echo=FALSE}
tribble(
  ~Status, ~Value, ~Code,
  # ----- | ---- | ----
  "severe", 1, 1,
  "not severe", 2, 0) %>%
  kable(caption = "Severity Encoding Map")
```

```{r encode-data}
# Encode severity == 1 as 1, All other values as 0.
Liver.2 <- Liver.1 %>%
          mutate(severity = as.integer(ifelse(severity == 1, 1, 0)))

# Preview the Liver tibble.
Liver.2
```
```{r save-data}
# Write the data to the `data/processed/` directory as `Liver.Rds`
write_rds(Liver.2, "data/processed/Liver.Rds")
```

Instead of using the `save()` function (which would save our entire environment), we'll save the single modified `Liver.2` object with `readr::write_rds()` wrapper for `saveRDS()`.

This method will allow us to import our intermediate data object into a new variable rather than dumping loose data objects into the environment, when using the `readRDS()` wrapper, `readr::read_rds()`.

<!-- PAGE BREAK -->
\newpage

## Classification

*2. Predict Variable 7 using logistic regression (using $p = P(\text{Group 1})$) with the remaining variables as predictors.*

```{r read-data}
# Read the processed intermediate file.
Liver <- read_rds("data/processed/Liver.Rds")
Liver[1,]
```

### Logistic Regression

$severity$ can only take one of two values: $0$ or $1$. We denote $p = P(severity = 1)$ and we will fit a logistic regression model:

$$
ln[\frac{p}{(1-p)}] = \beta_0 + \beta_1(blood.1) + \cdots + \beta_5(blood.5) + \beta_6(drinks)
$$
We will predict $severity = 1$ if $p > p_0$ and as $0$ otherwise.

```{r fit-model}
# Define and fit a logistic regression model.
fit.1 <- glm(severity ~ ., data=Liver, family="binomial")
```


### Model Analysis

```{r analyse-fit, results='hold'}
# Summary fit function from class.
Summary.fit <- function(fit.obj) {
  mat <- summary(fit.obj)$coef
  mat[,3] <- round(mat[,3], 2)
  mat[,4] <- round(mat[,4], 2)
  return(mat)
}

# Show results.
Summary.fit(fit.1)

fit.1.residuals <- as_tibble(residuals.glm(fit.1))
fit.1.residuals
```
<!-- Comment on the model fit summary -->

<!-- Residual analysis? -->

## Misclassification Error Analysis

*3. Minimize the total error of misclassification by changing the threshold for $p$. Show the results graphically, as we did in class, and also show the optimal values, including the misclassification table for that optimal case.*

```{r analyze-errors, results='hold'}
# Make the prediction needed with threshold set to p = 0.5.
p.threshold <- 0.5
fit.1.prediction <- (fit.1$fitted > p.threshold)

# Get the misclassification table.
(Classif.table <- table(fit.1.prediction, Liver$severity))

# Calculate the error rate.
Error.rate.fit <- function(mat) {
  # Assume a 2 by 2 table.
  (mat[1,2] + mat[2,1]) / sum(mat)
}

# Misclassification error rate:
Error.rate.fit(Classif.table)

# Normal 'at random' error rate:
sum(Liver$severity==0)/length(Liver$severity)
```


<!-- Minimize the total error of misclassification. -->

<!-- Show results graphically -->

<!-- Show the optimal values -->

<!-- Show misclassification for optimal case -->

## Crossvalidation

### $k = 10$-fold Crossvalidation

*4. Repeat Step 3 with 10-fold CV. Use 100 rounds. Calculate means and their standard errors of the minimized total error of misclassification.*

<!-- Perform 10-fold CV, 100 rounds -->

<!-- Calculate means -->

<!-- Calculate standard errors -->

### $k = 3$-fold Crossvalidation

*5. Repeat Step 3 with 3-fold CV. Use 100 rounds. Calculate means and their standard errors of the minimized total error of misclassification.*

<!-- Perform 3-fold CV, 100 rounds -->

<!-- Calculate means -->

<!-- Calculate standard errors -->


## Session Information

*This report was generated by the `vignettes/hw2_notebook.Rmd` file. The setup chunk for this document sets the root directory to the project root directory using the `rprojroot` package; all file paths are relative to the project root.*

```{r session-info, echo=FALSE, results='markup', cache=FALSE}
sessionInfo()
```
